// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	context "context"

	cryptov1 "github.com/cometbft/cometbft/api/cometbft/crypto/v1"
	mock "github.com/stretchr/testify/mock"

	time "time"

	typesv1 "github.com/cometbft/cometbft/api/cometbft/types/v1"

	v1 "github.com/cometbft/cometbft/api/cometbft/abci/v1"
)

// Application is an autogenerated mock type for the Application type
type Application struct {
	mock.Mock
}

// ApplySnapshotChunk provides a mock function with given fields: ctx, req
func (_m *Application) ApplySnapshotChunk(ctx context.Context, req *struct {
	Index  uint32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Chunk  []byte `protobuf:"bytes,2,opt,name=chunk,proto3" json:"chunk,omitempty"`
	Sender string `protobuf:"bytes,3,opt,name=sender,proto3" json:"sender,omitempty"`
}) (*struct {
	Result        v1.ApplySnapshotChunkResult `protobuf:"varint,1,opt,name=result,proto3,enum=cometbft.abci.v1.ApplySnapshotChunkResult" json:"result,omitempty"`
	RefetchChunks []uint32                    `protobuf:"varint,2,rep,packed,name=refetch_chunks,json=refetchChunks,proto3" json:"refetch_chunks,omitempty"`
	RejectSenders []string                    `protobuf:"bytes,3,rep,name=reject_senders,json=rejectSenders,proto3" json:"reject_senders,omitempty"`
}, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for ApplySnapshotChunk")
	}

	var r0 *struct {
		Result        v1.ApplySnapshotChunkResult `protobuf:"varint,1,opt,name=result,proto3,enum=cometbft.abci.v1.ApplySnapshotChunkResult" json:"result,omitempty"`
		RefetchChunks []uint32                    `protobuf:"varint,2,rep,packed,name=refetch_chunks,json=refetchChunks,proto3" json:"refetch_chunks,omitempty"`
		RejectSenders []string                    `protobuf:"bytes,3,rep,name=reject_senders,json=rejectSenders,proto3" json:"reject_senders,omitempty"`
	}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *struct {
		Index  uint32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
		Chunk  []byte `protobuf:"bytes,2,opt,name=chunk,proto3" json:"chunk,omitempty"`
		Sender string `protobuf:"bytes,3,opt,name=sender,proto3" json:"sender,omitempty"`
	}) (*struct {
		Result        v1.ApplySnapshotChunkResult `protobuf:"varint,1,opt,name=result,proto3,enum=cometbft.abci.v1.ApplySnapshotChunkResult" json:"result,omitempty"`
		RefetchChunks []uint32                    `protobuf:"varint,2,rep,packed,name=refetch_chunks,json=refetchChunks,proto3" json:"refetch_chunks,omitempty"`
		RejectSenders []string                    `protobuf:"bytes,3,rep,name=reject_senders,json=rejectSenders,proto3" json:"reject_senders,omitempty"`
	}, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *struct {
		Index  uint32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
		Chunk  []byte `protobuf:"bytes,2,opt,name=chunk,proto3" json:"chunk,omitempty"`
		Sender string `protobuf:"bytes,3,opt,name=sender,proto3" json:"sender,omitempty"`
	}) *struct {
		Result        v1.ApplySnapshotChunkResult `protobuf:"varint,1,opt,name=result,proto3,enum=cometbft.abci.v1.ApplySnapshotChunkResult" json:"result,omitempty"`
		RefetchChunks []uint32                    `protobuf:"varint,2,rep,packed,name=refetch_chunks,json=refetchChunks,proto3" json:"refetch_chunks,omitempty"`
		RejectSenders []string                    `protobuf:"bytes,3,rep,name=reject_senders,json=rejectSenders,proto3" json:"reject_senders,omitempty"`
	}); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*struct {
				Result        v1.ApplySnapshotChunkResult `protobuf:"varint,1,opt,name=result,proto3,enum=cometbft.abci.v1.ApplySnapshotChunkResult" json:"result,omitempty"`
				RefetchChunks []uint32                    `protobuf:"varint,2,rep,packed,name=refetch_chunks,json=refetchChunks,proto3" json:"refetch_chunks,omitempty"`
				RejectSenders []string                    `protobuf:"bytes,3,rep,name=reject_senders,json=rejectSenders,proto3" json:"reject_senders,omitempty"`
			})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *struct {
		Index  uint32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
		Chunk  []byte `protobuf:"bytes,2,opt,name=chunk,proto3" json:"chunk,omitempty"`
		Sender string `protobuf:"bytes,3,opt,name=sender,proto3" json:"sender,omitempty"`
	}) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CheckTx provides a mock function with given fields: ctx, req
func (_m *Application) CheckTx(ctx context.Context, req *struct {
	Tx   []byte         `protobuf:"bytes,1,opt,name=tx,proto3" json:"tx,omitempty"`
	Type v1.CheckTxType `protobuf:"varint,3,opt,name=type,proto3,enum=cometbft.abci.v1.CheckTxType" json:"type,omitempty"`
}) (*struct {
	Code      uint32     `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Data      []byte     `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	Log       string     `protobuf:"bytes,3,opt,name=log,proto3" json:"log,omitempty"`
	Info      string     `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
	GasWanted int64      `protobuf:"varint,5,opt,name=gas_wanted,proto3" json:"gas_wanted,omitempty"`
	GasUsed   int64      `protobuf:"varint,6,opt,name=gas_used,proto3" json:"gas_used,omitempty"`
	Events    []v1.Event `protobuf:"bytes,7,rep,name=events,proto3" json:"events,omitempty"`
	Codespace string     `protobuf:"bytes,8,opt,name=codespace,proto3" json:"codespace,omitempty"`
	LaneId    string     `protobuf:"bytes,12,opt,name=lane_id,json=laneId,proto3" json:"lane_id,omitempty"`
}, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for CheckTx")
	}

	var r0 *struct {
		Code      uint32     `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
		Data      []byte     `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
		Log       string     `protobuf:"bytes,3,opt,name=log,proto3" json:"log,omitempty"`
		Info      string     `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
		GasWanted int64      `protobuf:"varint,5,opt,name=gas_wanted,proto3" json:"gas_wanted,omitempty"`
		GasUsed   int64      `protobuf:"varint,6,opt,name=gas_used,proto3" json:"gas_used,omitempty"`
		Events    []v1.Event `protobuf:"bytes,7,rep,name=events,proto3" json:"events,omitempty"`
		Codespace string     `protobuf:"bytes,8,opt,name=codespace,proto3" json:"codespace,omitempty"`
		LaneId    string     `protobuf:"bytes,12,opt,name=lane_id,json=laneId,proto3" json:"lane_id,omitempty"`
	}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *struct {
		Tx   []byte         `protobuf:"bytes,1,opt,name=tx,proto3" json:"tx,omitempty"`
		Type v1.CheckTxType `protobuf:"varint,3,opt,name=type,proto3,enum=cometbft.abci.v1.CheckTxType" json:"type,omitempty"`
	}) (*struct {
		Code      uint32     `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
		Data      []byte     `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
		Log       string     `protobuf:"bytes,3,opt,name=log,proto3" json:"log,omitempty"`
		Info      string     `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
		GasWanted int64      `protobuf:"varint,5,opt,name=gas_wanted,proto3" json:"gas_wanted,omitempty"`
		GasUsed   int64      `protobuf:"varint,6,opt,name=gas_used,proto3" json:"gas_used,omitempty"`
		Events    []v1.Event `protobuf:"bytes,7,rep,name=events,proto3" json:"events,omitempty"`
		Codespace string     `protobuf:"bytes,8,opt,name=codespace,proto3" json:"codespace,omitempty"`
		LaneId    string     `protobuf:"bytes,12,opt,name=lane_id,json=laneId,proto3" json:"lane_id,omitempty"`
	}, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *struct {
		Tx   []byte         `protobuf:"bytes,1,opt,name=tx,proto3" json:"tx,omitempty"`
		Type v1.CheckTxType `protobuf:"varint,3,opt,name=type,proto3,enum=cometbft.abci.v1.CheckTxType" json:"type,omitempty"`
	}) *struct {
		Code      uint32     `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
		Data      []byte     `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
		Log       string     `protobuf:"bytes,3,opt,name=log,proto3" json:"log,omitempty"`
		Info      string     `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
		GasWanted int64      `protobuf:"varint,5,opt,name=gas_wanted,proto3" json:"gas_wanted,omitempty"`
		GasUsed   int64      `protobuf:"varint,6,opt,name=gas_used,proto3" json:"gas_used,omitempty"`
		Events    []v1.Event `protobuf:"bytes,7,rep,name=events,proto3" json:"events,omitempty"`
		Codespace string     `protobuf:"bytes,8,opt,name=codespace,proto3" json:"codespace,omitempty"`
		LaneId    string     `protobuf:"bytes,12,opt,name=lane_id,json=laneId,proto3" json:"lane_id,omitempty"`
	}); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*struct {
				Code      uint32     `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
				Data      []byte     `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
				Log       string     `protobuf:"bytes,3,opt,name=log,proto3" json:"log,omitempty"`
				Info      string     `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
				GasWanted int64      `protobuf:"varint,5,opt,name=gas_wanted,proto3" json:"gas_wanted,omitempty"`
				GasUsed   int64      `protobuf:"varint,6,opt,name=gas_used,proto3" json:"gas_used,omitempty"`
				Events    []v1.Event `protobuf:"bytes,7,rep,name=events,proto3" json:"events,omitempty"`
				Codespace string     `protobuf:"bytes,8,opt,name=codespace,proto3" json:"codespace,omitempty"`
				LaneId    string     `protobuf:"bytes,12,opt,name=lane_id,json=laneId,proto3" json:"lane_id,omitempty"`
			})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *struct {
		Tx   []byte         `protobuf:"bytes,1,opt,name=tx,proto3" json:"tx,omitempty"`
		Type v1.CheckTxType `protobuf:"varint,3,opt,name=type,proto3,enum=cometbft.abci.v1.CheckTxType" json:"type,omitempty"`
	}) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Commit provides a mock function with given fields: ctx, req
func (_m *Application) Commit(ctx context.Context, req *struct{}) (*struct {
	RetainHeight int64 `protobuf:"varint,3,opt,name=retain_height,json=retainHeight,proto3" json:"retain_height,omitempty"`
}, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Commit")
	}

	var r0 *struct {
		RetainHeight int64 `protobuf:"varint,3,opt,name=retain_height,json=retainHeight,proto3" json:"retain_height,omitempty"`
	}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *struct{}) (*struct {
		RetainHeight int64 `protobuf:"varint,3,opt,name=retain_height,json=retainHeight,proto3" json:"retain_height,omitempty"`
	}, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *struct{}) *struct {
		RetainHeight int64 `protobuf:"varint,3,opt,name=retain_height,json=retainHeight,proto3" json:"retain_height,omitempty"`
	}); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*struct {
				RetainHeight int64 `protobuf:"varint,3,opt,name=retain_height,json=retainHeight,proto3" json:"retain_height,omitempty"`
			})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *struct{}) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExtendVote provides a mock function with given fields: ctx, req
func (_m *Application) ExtendVote(ctx context.Context, req *struct {
	Hash               []byte           `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	Height             int64            `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	Time               time.Time        `protobuf:"bytes,3,opt,name=time,proto3,stdtime" json:"time"`
	Txs                [][]byte         `protobuf:"bytes,4,rep,name=txs,proto3" json:"txs,omitempty"`
	ProposedLastCommit v1.CommitInfo    `protobuf:"bytes,5,opt,name=proposed_last_commit,json=proposedLastCommit,proto3" json:"proposed_last_commit"`
	Misbehavior        []v1.Misbehavior `protobuf:"bytes,6,rep,name=misbehavior,proto3" json:"misbehavior"`
	NextValidatorsHash []byte           `protobuf:"bytes,7,opt,name=next_validators_hash,json=nextValidatorsHash,proto3" json:"next_validators_hash,omitempty"`
	ProposerAddress    []byte           `protobuf:"bytes,8,opt,name=proposer_address,json=proposerAddress,proto3" json:"proposer_address,omitempty"`
}) (*struct {
	VoteExtension []byte `protobuf:"bytes,1,opt,name=vote_extension,json=voteExtension,proto3" json:"vote_extension,omitempty"`
}, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for ExtendVote")
	}

	var r0 *struct {
		VoteExtension []byte `protobuf:"bytes,1,opt,name=vote_extension,json=voteExtension,proto3" json:"vote_extension,omitempty"`
	}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *struct {
		Hash               []byte           `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
		Height             int64            `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
		Time               time.Time        `protobuf:"bytes,3,opt,name=time,proto3,stdtime" json:"time"`
		Txs                [][]byte         `protobuf:"bytes,4,rep,name=txs,proto3" json:"txs,omitempty"`
		ProposedLastCommit v1.CommitInfo    `protobuf:"bytes,5,opt,name=proposed_last_commit,json=proposedLastCommit,proto3" json:"proposed_last_commit"`
		Misbehavior        []v1.Misbehavior `protobuf:"bytes,6,rep,name=misbehavior,proto3" json:"misbehavior"`
		NextValidatorsHash []byte           `protobuf:"bytes,7,opt,name=next_validators_hash,json=nextValidatorsHash,proto3" json:"next_validators_hash,omitempty"`
		ProposerAddress    []byte           `protobuf:"bytes,8,opt,name=proposer_address,json=proposerAddress,proto3" json:"proposer_address,omitempty"`
	}) (*struct {
		VoteExtension []byte `protobuf:"bytes,1,opt,name=vote_extension,json=voteExtension,proto3" json:"vote_extension,omitempty"`
	}, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *struct {
		Hash               []byte           `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
		Height             int64            `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
		Time               time.Time        `protobuf:"bytes,3,opt,name=time,proto3,stdtime" json:"time"`
		Txs                [][]byte         `protobuf:"bytes,4,rep,name=txs,proto3" json:"txs,omitempty"`
		ProposedLastCommit v1.CommitInfo    `protobuf:"bytes,5,opt,name=proposed_last_commit,json=proposedLastCommit,proto3" json:"proposed_last_commit"`
		Misbehavior        []v1.Misbehavior `protobuf:"bytes,6,rep,name=misbehavior,proto3" json:"misbehavior"`
		NextValidatorsHash []byte           `protobuf:"bytes,7,opt,name=next_validators_hash,json=nextValidatorsHash,proto3" json:"next_validators_hash,omitempty"`
		ProposerAddress    []byte           `protobuf:"bytes,8,opt,name=proposer_address,json=proposerAddress,proto3" json:"proposer_address,omitempty"`
	}) *struct {
		VoteExtension []byte `protobuf:"bytes,1,opt,name=vote_extension,json=voteExtension,proto3" json:"vote_extension,omitempty"`
	}); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*struct {
				VoteExtension []byte `protobuf:"bytes,1,opt,name=vote_extension,json=voteExtension,proto3" json:"vote_extension,omitempty"`
			})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *struct {
		Hash               []byte           `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
		Height             int64            `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
		Time               time.Time        `protobuf:"bytes,3,opt,name=time,proto3,stdtime" json:"time"`
		Txs                [][]byte         `protobuf:"bytes,4,rep,name=txs,proto3" json:"txs,omitempty"`
		ProposedLastCommit v1.CommitInfo    `protobuf:"bytes,5,opt,name=proposed_last_commit,json=proposedLastCommit,proto3" json:"proposed_last_commit"`
		Misbehavior        []v1.Misbehavior `protobuf:"bytes,6,rep,name=misbehavior,proto3" json:"misbehavior"`
		NextValidatorsHash []byte           `protobuf:"bytes,7,opt,name=next_validators_hash,json=nextValidatorsHash,proto3" json:"next_validators_hash,omitempty"`
		ProposerAddress    []byte           `protobuf:"bytes,8,opt,name=proposer_address,json=proposerAddress,proto3" json:"proposer_address,omitempty"`
	}) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FinalizeBlock provides a mock function with given fields: ctx, req
func (_m *Application) FinalizeBlock(ctx context.Context, req *struct {
	Txs                [][]byte         `protobuf:"bytes,1,rep,name=txs,proto3" json:"txs,omitempty"`
	DecidedLastCommit  v1.CommitInfo    `protobuf:"bytes,2,opt,name=decided_last_commit,json=decidedLastCommit,proto3" json:"decided_last_commit"`
	Misbehavior        []v1.Misbehavior `protobuf:"bytes,3,rep,name=misbehavior,proto3" json:"misbehavior"`
	Hash               []byte           `protobuf:"bytes,4,opt,name=hash,proto3" json:"hash,omitempty"`
	Height             int64            `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
	Time               time.Time        `protobuf:"bytes,6,opt,name=time,proto3,stdtime" json:"time"`
	NextValidatorsHash []byte           `protobuf:"bytes,7,opt,name=next_validators_hash,json=nextValidatorsHash,proto3" json:"next_validators_hash,omitempty"`
	ProposerAddress    []byte           `protobuf:"bytes,8,opt,name=proposer_address,json=proposerAddress,proto3" json:"proposer_address,omitempty"`
	SyncingToHeight    int64            `protobuf:"varint,9,opt,name=syncing_to_height,json=syncingToHeight,proto3" json:"syncing_to_height,omitempty"`
}) (*struct {
	Events                []v1.Event               `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
	TxResults             []*v1.ExecTxResult       `protobuf:"bytes,2,rep,name=tx_results,json=txResults,proto3" json:"tx_results,omitempty"`
	ValidatorUpdates      []v1.ValidatorUpdate     `protobuf:"bytes,3,rep,name=validator_updates,json=validatorUpdates,proto3" json:"validator_updates"`
	ConsensusParamUpdates *typesv1.ConsensusParams `protobuf:"bytes,4,opt,name=consensus_param_updates,json=consensusParamUpdates,proto3" json:"consensus_param_updates,omitempty"`
	AppHash               []byte                   `protobuf:"bytes,5,opt,name=app_hash,json=appHash,proto3" json:"app_hash,omitempty"`
	NextBlockDelay        time.Duration            `protobuf:"bytes,6,opt,name=next_block_delay,json=nextBlockDelay,proto3,stdduration" json:"next_block_delay"`
}, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for FinalizeBlock")
	}

	var r0 *struct {
		Events                []v1.Event               `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
		TxResults             []*v1.ExecTxResult       `protobuf:"bytes,2,rep,name=tx_results,json=txResults,proto3" json:"tx_results,omitempty"`
		ValidatorUpdates      []v1.ValidatorUpdate     `protobuf:"bytes,3,rep,name=validator_updates,json=validatorUpdates,proto3" json:"validator_updates"`
		ConsensusParamUpdates *typesv1.ConsensusParams `protobuf:"bytes,4,opt,name=consensus_param_updates,json=consensusParamUpdates,proto3" json:"consensus_param_updates,omitempty"`
		AppHash               []byte                   `protobuf:"bytes,5,opt,name=app_hash,json=appHash,proto3" json:"app_hash,omitempty"`
		NextBlockDelay        time.Duration            `protobuf:"bytes,6,opt,name=next_block_delay,json=nextBlockDelay,proto3,stdduration" json:"next_block_delay"`
	}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *struct {
		Txs                [][]byte         `protobuf:"bytes,1,rep,name=txs,proto3" json:"txs,omitempty"`
		DecidedLastCommit  v1.CommitInfo    `protobuf:"bytes,2,opt,name=decided_last_commit,json=decidedLastCommit,proto3" json:"decided_last_commit"`
		Misbehavior        []v1.Misbehavior `protobuf:"bytes,3,rep,name=misbehavior,proto3" json:"misbehavior"`
		Hash               []byte           `protobuf:"bytes,4,opt,name=hash,proto3" json:"hash,omitempty"`
		Height             int64            `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
		Time               time.Time        `protobuf:"bytes,6,opt,name=time,proto3,stdtime" json:"time"`
		NextValidatorsHash []byte           `protobuf:"bytes,7,opt,name=next_validators_hash,json=nextValidatorsHash,proto3" json:"next_validators_hash,omitempty"`
		ProposerAddress    []byte           `protobuf:"bytes,8,opt,name=proposer_address,json=proposerAddress,proto3" json:"proposer_address,omitempty"`
		SyncingToHeight    int64            `protobuf:"varint,9,opt,name=syncing_to_height,json=syncingToHeight,proto3" json:"syncing_to_height,omitempty"`
	}) (*struct {
		Events                []v1.Event               `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
		TxResults             []*v1.ExecTxResult       `protobuf:"bytes,2,rep,name=tx_results,json=txResults,proto3" json:"tx_results,omitempty"`
		ValidatorUpdates      []v1.ValidatorUpdate     `protobuf:"bytes,3,rep,name=validator_updates,json=validatorUpdates,proto3" json:"validator_updates"`
		ConsensusParamUpdates *typesv1.ConsensusParams `protobuf:"bytes,4,opt,name=consensus_param_updates,json=consensusParamUpdates,proto3" json:"consensus_param_updates,omitempty"`
		AppHash               []byte                   `protobuf:"bytes,5,opt,name=app_hash,json=appHash,proto3" json:"app_hash,omitempty"`
		NextBlockDelay        time.Duration            `protobuf:"bytes,6,opt,name=next_block_delay,json=nextBlockDelay,proto3,stdduration" json:"next_block_delay"`
	}, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *struct {
		Txs                [][]byte         `protobuf:"bytes,1,rep,name=txs,proto3" json:"txs,omitempty"`
		DecidedLastCommit  v1.CommitInfo    `protobuf:"bytes,2,opt,name=decided_last_commit,json=decidedLastCommit,proto3" json:"decided_last_commit"`
		Misbehavior        []v1.Misbehavior `protobuf:"bytes,3,rep,name=misbehavior,proto3" json:"misbehavior"`
		Hash               []byte           `protobuf:"bytes,4,opt,name=hash,proto3" json:"hash,omitempty"`
		Height             int64            `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
		Time               time.Time        `protobuf:"bytes,6,opt,name=time,proto3,stdtime" json:"time"`
		NextValidatorsHash []byte           `protobuf:"bytes,7,opt,name=next_validators_hash,json=nextValidatorsHash,proto3" json:"next_validators_hash,omitempty"`
		ProposerAddress    []byte           `protobuf:"bytes,8,opt,name=proposer_address,json=proposerAddress,proto3" json:"proposer_address,omitempty"`
		SyncingToHeight    int64            `protobuf:"varint,9,opt,name=syncing_to_height,json=syncingToHeight,proto3" json:"syncing_to_height,omitempty"`
	}) *struct {
		Events                []v1.Event               `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
		TxResults             []*v1.ExecTxResult       `protobuf:"bytes,2,rep,name=tx_results,json=txResults,proto3" json:"tx_results,omitempty"`
		ValidatorUpdates      []v1.ValidatorUpdate     `protobuf:"bytes,3,rep,name=validator_updates,json=validatorUpdates,proto3" json:"validator_updates"`
		ConsensusParamUpdates *typesv1.ConsensusParams `protobuf:"bytes,4,opt,name=consensus_param_updates,json=consensusParamUpdates,proto3" json:"consensus_param_updates,omitempty"`
		AppHash               []byte                   `protobuf:"bytes,5,opt,name=app_hash,json=appHash,proto3" json:"app_hash,omitempty"`
		NextBlockDelay        time.Duration            `protobuf:"bytes,6,opt,name=next_block_delay,json=nextBlockDelay,proto3,stdduration" json:"next_block_delay"`
	}); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*struct {
				Events                []v1.Event               `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
				TxResults             []*v1.ExecTxResult       `protobuf:"bytes,2,rep,name=tx_results,json=txResults,proto3" json:"tx_results,omitempty"`
				ValidatorUpdates      []v1.ValidatorUpdate     `protobuf:"bytes,3,rep,name=validator_updates,json=validatorUpdates,proto3" json:"validator_updates"`
				ConsensusParamUpdates *typesv1.ConsensusParams `protobuf:"bytes,4,opt,name=consensus_param_updates,json=consensusParamUpdates,proto3" json:"consensus_param_updates,omitempty"`
				AppHash               []byte                   `protobuf:"bytes,5,opt,name=app_hash,json=appHash,proto3" json:"app_hash,omitempty"`
				NextBlockDelay        time.Duration            `protobuf:"bytes,6,opt,name=next_block_delay,json=nextBlockDelay,proto3,stdduration" json:"next_block_delay"`
			})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *struct {
		Txs                [][]byte         `protobuf:"bytes,1,rep,name=txs,proto3" json:"txs,omitempty"`
		DecidedLastCommit  v1.CommitInfo    `protobuf:"bytes,2,opt,name=decided_last_commit,json=decidedLastCommit,proto3" json:"decided_last_commit"`
		Misbehavior        []v1.Misbehavior `protobuf:"bytes,3,rep,name=misbehavior,proto3" json:"misbehavior"`
		Hash               []byte           `protobuf:"bytes,4,opt,name=hash,proto3" json:"hash,omitempty"`
		Height             int64            `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
		Time               time.Time        `protobuf:"bytes,6,opt,name=time,proto3,stdtime" json:"time"`
		NextValidatorsHash []byte           `protobuf:"bytes,7,opt,name=next_validators_hash,json=nextValidatorsHash,proto3" json:"next_validators_hash,omitempty"`
		ProposerAddress    []byte           `protobuf:"bytes,8,opt,name=proposer_address,json=proposerAddress,proto3" json:"proposer_address,omitempty"`
		SyncingToHeight    int64            `protobuf:"varint,9,opt,name=syncing_to_height,json=syncingToHeight,proto3" json:"syncing_to_height,omitempty"`
	}) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Info provides a mock function with given fields: ctx, req
func (_m *Application) Info(ctx context.Context, req *struct {
	Version      string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	BlockVersion uint64 `protobuf:"varint,2,opt,name=block_version,json=blockVersion,proto3" json:"block_version,omitempty"`
	P2PVersion   uint64 `protobuf:"varint,3,opt,name=p2p_version,json=p2pVersion,proto3" json:"p2p_version,omitempty"`
	AbciVersion  string `protobuf:"bytes,4,opt,name=abci_version,json=abciVersion,proto3" json:"abci_version,omitempty"`
}) (*struct {
	Data             string            `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Version          string            `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	AppVersion       uint64            `protobuf:"varint,3,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
	LastBlockHeight  int64             `protobuf:"varint,4,opt,name=last_block_height,json=lastBlockHeight,proto3" json:"last_block_height,omitempty"`
	LastBlockAppHash []byte            `protobuf:"bytes,5,opt,name=last_block_app_hash,json=lastBlockAppHash,proto3" json:"last_block_app_hash,omitempty"`
	LanePriorities   map[string]uint32 `protobuf:"bytes,6,rep,name=lane_priorities,json=lanePriorities,proto3" json:"lane_priorities,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	DefaultLane      string            `protobuf:"bytes,7,opt,name=default_lane,json=defaultLane,proto3" json:"default_lane,omitempty"`
}, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Info")
	}

	var r0 *struct {
		Data             string            `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
		Version          string            `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
		AppVersion       uint64            `protobuf:"varint,3,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
		LastBlockHeight  int64             `protobuf:"varint,4,opt,name=last_block_height,json=lastBlockHeight,proto3" json:"last_block_height,omitempty"`
		LastBlockAppHash []byte            `protobuf:"bytes,5,opt,name=last_block_app_hash,json=lastBlockAppHash,proto3" json:"last_block_app_hash,omitempty"`
		LanePriorities   map[string]uint32 `protobuf:"bytes,6,rep,name=lane_priorities,json=lanePriorities,proto3" json:"lane_priorities,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
		DefaultLane      string            `protobuf:"bytes,7,opt,name=default_lane,json=defaultLane,proto3" json:"default_lane,omitempty"`
	}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *struct {
		Version      string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
		BlockVersion uint64 `protobuf:"varint,2,opt,name=block_version,json=blockVersion,proto3" json:"block_version,omitempty"`
		P2PVersion   uint64 `protobuf:"varint,3,opt,name=p2p_version,json=p2pVersion,proto3" json:"p2p_version,omitempty"`
		AbciVersion  string `protobuf:"bytes,4,opt,name=abci_version,json=abciVersion,proto3" json:"abci_version,omitempty"`
	}) (*struct {
		Data             string            `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
		Version          string            `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
		AppVersion       uint64            `protobuf:"varint,3,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
		LastBlockHeight  int64             `protobuf:"varint,4,opt,name=last_block_height,json=lastBlockHeight,proto3" json:"last_block_height,omitempty"`
		LastBlockAppHash []byte            `protobuf:"bytes,5,opt,name=last_block_app_hash,json=lastBlockAppHash,proto3" json:"last_block_app_hash,omitempty"`
		LanePriorities   map[string]uint32 `protobuf:"bytes,6,rep,name=lane_priorities,json=lanePriorities,proto3" json:"lane_priorities,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
		DefaultLane      string            `protobuf:"bytes,7,opt,name=default_lane,json=defaultLane,proto3" json:"default_lane,omitempty"`
	}, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *struct {
		Version      string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
		BlockVersion uint64 `protobuf:"varint,2,opt,name=block_version,json=blockVersion,proto3" json:"block_version,omitempty"`
		P2PVersion   uint64 `protobuf:"varint,3,opt,name=p2p_version,json=p2pVersion,proto3" json:"p2p_version,omitempty"`
		AbciVersion  string `protobuf:"bytes,4,opt,name=abci_version,json=abciVersion,proto3" json:"abci_version,omitempty"`
	}) *struct {
		Data             string            `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
		Version          string            `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
		AppVersion       uint64            `protobuf:"varint,3,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
		LastBlockHeight  int64             `protobuf:"varint,4,opt,name=last_block_height,json=lastBlockHeight,proto3" json:"last_block_height,omitempty"`
		LastBlockAppHash []byte            `protobuf:"bytes,5,opt,name=last_block_app_hash,json=lastBlockAppHash,proto3" json:"last_block_app_hash,omitempty"`
		LanePriorities   map[string]uint32 `protobuf:"bytes,6,rep,name=lane_priorities,json=lanePriorities,proto3" json:"lane_priorities,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
		DefaultLane      string            `protobuf:"bytes,7,opt,name=default_lane,json=defaultLane,proto3" json:"default_lane,omitempty"`
	}); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*struct {
				Data             string            `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
				Version          string            `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
				AppVersion       uint64            `protobuf:"varint,3,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
				LastBlockHeight  int64             `protobuf:"varint,4,opt,name=last_block_height,json=lastBlockHeight,proto3" json:"last_block_height,omitempty"`
				LastBlockAppHash []byte            `protobuf:"bytes,5,opt,name=last_block_app_hash,json=lastBlockAppHash,proto3" json:"last_block_app_hash,omitempty"`
				LanePriorities   map[string]uint32 `protobuf:"bytes,6,rep,name=lane_priorities,json=lanePriorities,proto3" json:"lane_priorities,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
				DefaultLane      string            `protobuf:"bytes,7,opt,name=default_lane,json=defaultLane,proto3" json:"default_lane,omitempty"`
			})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *struct {
		Version      string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
		BlockVersion uint64 `protobuf:"varint,2,opt,name=block_version,json=blockVersion,proto3" json:"block_version,omitempty"`
		P2PVersion   uint64 `protobuf:"varint,3,opt,name=p2p_version,json=p2pVersion,proto3" json:"p2p_version,omitempty"`
		AbciVersion  string `protobuf:"bytes,4,opt,name=abci_version,json=abciVersion,proto3" json:"abci_version,omitempty"`
	}) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InitChain provides a mock function with given fields: ctx, req
func (_m *Application) InitChain(ctx context.Context, req *struct {
	Time            time.Time                `protobuf:"bytes,1,opt,name=time,proto3,stdtime" json:"time"`
	ChainId         string                   `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	ConsensusParams *typesv1.ConsensusParams `protobuf:"bytes,3,opt,name=consensus_params,json=consensusParams,proto3" json:"consensus_params,omitempty"`
	Validators      []v1.ValidatorUpdate     `protobuf:"bytes,4,rep,name=validators,proto3" json:"validators"`
	AppStateBytes   []byte                   `protobuf:"bytes,5,opt,name=app_state_bytes,json=appStateBytes,proto3" json:"app_state_bytes,omitempty"`
	InitialHeight   int64                    `protobuf:"varint,6,opt,name=initial_height,json=initialHeight,proto3" json:"initial_height,omitempty"`
}) (*struct {
	ConsensusParams *typesv1.ConsensusParams `protobuf:"bytes,1,opt,name=consensus_params,json=consensusParams,proto3" json:"consensus_params,omitempty"`
	Validators      []v1.ValidatorUpdate     `protobuf:"bytes,2,rep,name=validators,proto3" json:"validators"`
	AppHash         []byte                   `protobuf:"bytes,3,opt,name=app_hash,json=appHash,proto3" json:"app_hash,omitempty"`
}, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for InitChain")
	}

	var r0 *struct {
		ConsensusParams *typesv1.ConsensusParams `protobuf:"bytes,1,opt,name=consensus_params,json=consensusParams,proto3" json:"consensus_params,omitempty"`
		Validators      []v1.ValidatorUpdate     `protobuf:"bytes,2,rep,name=validators,proto3" json:"validators"`
		AppHash         []byte                   `protobuf:"bytes,3,opt,name=app_hash,json=appHash,proto3" json:"app_hash,omitempty"`
	}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *struct {
		Time            time.Time                `protobuf:"bytes,1,opt,name=time,proto3,stdtime" json:"time"`
		ChainId         string                   `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
		ConsensusParams *typesv1.ConsensusParams `protobuf:"bytes,3,opt,name=consensus_params,json=consensusParams,proto3" json:"consensus_params,omitempty"`
		Validators      []v1.ValidatorUpdate     `protobuf:"bytes,4,rep,name=validators,proto3" json:"validators"`
		AppStateBytes   []byte                   `protobuf:"bytes,5,opt,name=app_state_bytes,json=appStateBytes,proto3" json:"app_state_bytes,omitempty"`
		InitialHeight   int64                    `protobuf:"varint,6,opt,name=initial_height,json=initialHeight,proto3" json:"initial_height,omitempty"`
	}) (*struct {
		ConsensusParams *typesv1.ConsensusParams `protobuf:"bytes,1,opt,name=consensus_params,json=consensusParams,proto3" json:"consensus_params,omitempty"`
		Validators      []v1.ValidatorUpdate     `protobuf:"bytes,2,rep,name=validators,proto3" json:"validators"`
		AppHash         []byte                   `protobuf:"bytes,3,opt,name=app_hash,json=appHash,proto3" json:"app_hash,omitempty"`
	}, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *struct {
		Time            time.Time                `protobuf:"bytes,1,opt,name=time,proto3,stdtime" json:"time"`
		ChainId         string                   `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
		ConsensusParams *typesv1.ConsensusParams `protobuf:"bytes,3,opt,name=consensus_params,json=consensusParams,proto3" json:"consensus_params,omitempty"`
		Validators      []v1.ValidatorUpdate     `protobuf:"bytes,4,rep,name=validators,proto3" json:"validators"`
		AppStateBytes   []byte                   `protobuf:"bytes,5,opt,name=app_state_bytes,json=appStateBytes,proto3" json:"app_state_bytes,omitempty"`
		InitialHeight   int64                    `protobuf:"varint,6,opt,name=initial_height,json=initialHeight,proto3" json:"initial_height,omitempty"`
	}) *struct {
		ConsensusParams *typesv1.ConsensusParams `protobuf:"bytes,1,opt,name=consensus_params,json=consensusParams,proto3" json:"consensus_params,omitempty"`
		Validators      []v1.ValidatorUpdate     `protobuf:"bytes,2,rep,name=validators,proto3" json:"validators"`
		AppHash         []byte                   `protobuf:"bytes,3,opt,name=app_hash,json=appHash,proto3" json:"app_hash,omitempty"`
	}); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*struct {
				ConsensusParams *typesv1.ConsensusParams `protobuf:"bytes,1,opt,name=consensus_params,json=consensusParams,proto3" json:"consensus_params,omitempty"`
				Validators      []v1.ValidatorUpdate     `protobuf:"bytes,2,rep,name=validators,proto3" json:"validators"`
				AppHash         []byte                   `protobuf:"bytes,3,opt,name=app_hash,json=appHash,proto3" json:"app_hash,omitempty"`
			})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *struct {
		Time            time.Time                `protobuf:"bytes,1,opt,name=time,proto3,stdtime" json:"time"`
		ChainId         string                   `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
		ConsensusParams *typesv1.ConsensusParams `protobuf:"bytes,3,opt,name=consensus_params,json=consensusParams,proto3" json:"consensus_params,omitempty"`
		Validators      []v1.ValidatorUpdate     `protobuf:"bytes,4,rep,name=validators,proto3" json:"validators"`
		AppStateBytes   []byte                   `protobuf:"bytes,5,opt,name=app_state_bytes,json=appStateBytes,proto3" json:"app_state_bytes,omitempty"`
		InitialHeight   int64                    `protobuf:"varint,6,opt,name=initial_height,json=initialHeight,proto3" json:"initial_height,omitempty"`
	}) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSnapshots provides a mock function with given fields: ctx, req
func (_m *Application) ListSnapshots(ctx context.Context, req *struct{}) (*struct {
	Snapshots []*v1.Snapshot `protobuf:"bytes,1,rep,name=snapshots,proto3" json:"snapshots,omitempty"`
}, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for ListSnapshots")
	}

	var r0 *struct {
		Snapshots []*v1.Snapshot `protobuf:"bytes,1,rep,name=snapshots,proto3" json:"snapshots,omitempty"`
	}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *struct{}) (*struct {
		Snapshots []*v1.Snapshot `protobuf:"bytes,1,rep,name=snapshots,proto3" json:"snapshots,omitempty"`
	}, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *struct{}) *struct {
		Snapshots []*v1.Snapshot `protobuf:"bytes,1,rep,name=snapshots,proto3" json:"snapshots,omitempty"`
	}); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*struct {
				Snapshots []*v1.Snapshot `protobuf:"bytes,1,rep,name=snapshots,proto3" json:"snapshots,omitempty"`
			})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *struct{}) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoadSnapshotChunk provides a mock function with given fields: ctx, req
func (_m *Application) LoadSnapshotChunk(ctx context.Context, req *struct {
	Height uint64 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	Format uint32 `protobuf:"varint,2,opt,name=format,proto3" json:"format,omitempty"`
	Chunk  uint32 `protobuf:"varint,3,opt,name=chunk,proto3" json:"chunk,omitempty"`
}) (*struct {
	Chunk []byte `protobuf:"bytes,1,opt,name=chunk,proto3" json:"chunk,omitempty"`
}, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for LoadSnapshotChunk")
	}

	var r0 *struct {
		Chunk []byte `protobuf:"bytes,1,opt,name=chunk,proto3" json:"chunk,omitempty"`
	}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *struct {
		Height uint64 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
		Format uint32 `protobuf:"varint,2,opt,name=format,proto3" json:"format,omitempty"`
		Chunk  uint32 `protobuf:"varint,3,opt,name=chunk,proto3" json:"chunk,omitempty"`
	}) (*struct {
		Chunk []byte `protobuf:"bytes,1,opt,name=chunk,proto3" json:"chunk,omitempty"`
	}, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *struct {
		Height uint64 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
		Format uint32 `protobuf:"varint,2,opt,name=format,proto3" json:"format,omitempty"`
		Chunk  uint32 `protobuf:"varint,3,opt,name=chunk,proto3" json:"chunk,omitempty"`
	}) *struct {
		Chunk []byte `protobuf:"bytes,1,opt,name=chunk,proto3" json:"chunk,omitempty"`
	}); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*struct {
				Chunk []byte `protobuf:"bytes,1,opt,name=chunk,proto3" json:"chunk,omitempty"`
			})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *struct {
		Height uint64 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
		Format uint32 `protobuf:"varint,2,opt,name=format,proto3" json:"format,omitempty"`
		Chunk  uint32 `protobuf:"varint,3,opt,name=chunk,proto3" json:"chunk,omitempty"`
	}) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OfferSnapshot provides a mock function with given fields: ctx, req
func (_m *Application) OfferSnapshot(ctx context.Context, req *struct {
	Snapshot *v1.Snapshot `protobuf:"bytes,1,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	AppHash  []byte       `protobuf:"bytes,2,opt,name=app_hash,json=appHash,proto3" json:"app_hash,omitempty"`
}) (*struct {
	Result v1.OfferSnapshotResult `protobuf:"varint,1,opt,name=result,proto3,enum=cometbft.abci.v1.OfferSnapshotResult" json:"result,omitempty"`
}, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for OfferSnapshot")
	}

	var r0 *struct {
		Result v1.OfferSnapshotResult `protobuf:"varint,1,opt,name=result,proto3,enum=cometbft.abci.v1.OfferSnapshotResult" json:"result,omitempty"`
	}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *struct {
		Snapshot *v1.Snapshot `protobuf:"bytes,1,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
		AppHash  []byte       `protobuf:"bytes,2,opt,name=app_hash,json=appHash,proto3" json:"app_hash,omitempty"`
	}) (*struct {
		Result v1.OfferSnapshotResult `protobuf:"varint,1,opt,name=result,proto3,enum=cometbft.abci.v1.OfferSnapshotResult" json:"result,omitempty"`
	}, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *struct {
		Snapshot *v1.Snapshot `protobuf:"bytes,1,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
		AppHash  []byte       `protobuf:"bytes,2,opt,name=app_hash,json=appHash,proto3" json:"app_hash,omitempty"`
	}) *struct {
		Result v1.OfferSnapshotResult `protobuf:"varint,1,opt,name=result,proto3,enum=cometbft.abci.v1.OfferSnapshotResult" json:"result,omitempty"`
	}); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*struct {
				Result v1.OfferSnapshotResult `protobuf:"varint,1,opt,name=result,proto3,enum=cometbft.abci.v1.OfferSnapshotResult" json:"result,omitempty"`
			})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *struct {
		Snapshot *v1.Snapshot `protobuf:"bytes,1,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
		AppHash  []byte       `protobuf:"bytes,2,opt,name=app_hash,json=appHash,proto3" json:"app_hash,omitempty"`
	}) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PrepareProposal provides a mock function with given fields: ctx, req
func (_m *Application) PrepareProposal(ctx context.Context, req *struct {
	MaxTxBytes         int64                 `protobuf:"varint,1,opt,name=max_tx_bytes,json=maxTxBytes,proto3" json:"max_tx_bytes,omitempty"`
	Txs                [][]byte              `protobuf:"bytes,2,rep,name=txs,proto3" json:"txs,omitempty"`
	LocalLastCommit    v1.ExtendedCommitInfo `protobuf:"bytes,3,opt,name=local_last_commit,json=localLastCommit,proto3" json:"local_last_commit"`
	Misbehavior        []v1.Misbehavior      `protobuf:"bytes,4,rep,name=misbehavior,proto3" json:"misbehavior"`
	Height             int64                 `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
	Time               time.Time             `protobuf:"bytes,6,opt,name=time,proto3,stdtime" json:"time"`
	NextValidatorsHash []byte                `protobuf:"bytes,7,opt,name=next_validators_hash,json=nextValidatorsHash,proto3" json:"next_validators_hash,omitempty"`
	ProposerAddress    []byte                `protobuf:"bytes,8,opt,name=proposer_address,json=proposerAddress,proto3" json:"proposer_address,omitempty"`
}) (*struct {
	Txs [][]byte `protobuf:"bytes,1,rep,name=txs,proto3" json:"txs,omitempty"`
}, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for PrepareProposal")
	}

	var r0 *struct {
		Txs [][]byte `protobuf:"bytes,1,rep,name=txs,proto3" json:"txs,omitempty"`
	}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *struct {
		MaxTxBytes         int64                 `protobuf:"varint,1,opt,name=max_tx_bytes,json=maxTxBytes,proto3" json:"max_tx_bytes,omitempty"`
		Txs                [][]byte              `protobuf:"bytes,2,rep,name=txs,proto3" json:"txs,omitempty"`
		LocalLastCommit    v1.ExtendedCommitInfo `protobuf:"bytes,3,opt,name=local_last_commit,json=localLastCommit,proto3" json:"local_last_commit"`
		Misbehavior        []v1.Misbehavior      `protobuf:"bytes,4,rep,name=misbehavior,proto3" json:"misbehavior"`
		Height             int64                 `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
		Time               time.Time             `protobuf:"bytes,6,opt,name=time,proto3,stdtime" json:"time"`
		NextValidatorsHash []byte                `protobuf:"bytes,7,opt,name=next_validators_hash,json=nextValidatorsHash,proto3" json:"next_validators_hash,omitempty"`
		ProposerAddress    []byte                `protobuf:"bytes,8,opt,name=proposer_address,json=proposerAddress,proto3" json:"proposer_address,omitempty"`
	}) (*struct {
		Txs [][]byte `protobuf:"bytes,1,rep,name=txs,proto3" json:"txs,omitempty"`
	}, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *struct {
		MaxTxBytes         int64                 `protobuf:"varint,1,opt,name=max_tx_bytes,json=maxTxBytes,proto3" json:"max_tx_bytes,omitempty"`
		Txs                [][]byte              `protobuf:"bytes,2,rep,name=txs,proto3" json:"txs,omitempty"`
		LocalLastCommit    v1.ExtendedCommitInfo `protobuf:"bytes,3,opt,name=local_last_commit,json=localLastCommit,proto3" json:"local_last_commit"`
		Misbehavior        []v1.Misbehavior      `protobuf:"bytes,4,rep,name=misbehavior,proto3" json:"misbehavior"`
		Height             int64                 `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
		Time               time.Time             `protobuf:"bytes,6,opt,name=time,proto3,stdtime" json:"time"`
		NextValidatorsHash []byte                `protobuf:"bytes,7,opt,name=next_validators_hash,json=nextValidatorsHash,proto3" json:"next_validators_hash,omitempty"`
		ProposerAddress    []byte                `protobuf:"bytes,8,opt,name=proposer_address,json=proposerAddress,proto3" json:"proposer_address,omitempty"`
	}) *struct {
		Txs [][]byte `protobuf:"bytes,1,rep,name=txs,proto3" json:"txs,omitempty"`
	}); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*struct {
				Txs [][]byte `protobuf:"bytes,1,rep,name=txs,proto3" json:"txs,omitempty"`
			})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *struct {
		MaxTxBytes         int64                 `protobuf:"varint,1,opt,name=max_tx_bytes,json=maxTxBytes,proto3" json:"max_tx_bytes,omitempty"`
		Txs                [][]byte              `protobuf:"bytes,2,rep,name=txs,proto3" json:"txs,omitempty"`
		LocalLastCommit    v1.ExtendedCommitInfo `protobuf:"bytes,3,opt,name=local_last_commit,json=localLastCommit,proto3" json:"local_last_commit"`
		Misbehavior        []v1.Misbehavior      `protobuf:"bytes,4,rep,name=misbehavior,proto3" json:"misbehavior"`
		Height             int64                 `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
		Time               time.Time             `protobuf:"bytes,6,opt,name=time,proto3,stdtime" json:"time"`
		NextValidatorsHash []byte                `protobuf:"bytes,7,opt,name=next_validators_hash,json=nextValidatorsHash,proto3" json:"next_validators_hash,omitempty"`
		ProposerAddress    []byte                `protobuf:"bytes,8,opt,name=proposer_address,json=proposerAddress,proto3" json:"proposer_address,omitempty"`
	}) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProcessProposal provides a mock function with given fields: ctx, req
func (_m *Application) ProcessProposal(ctx context.Context, req *struct {
	Txs                [][]byte         `protobuf:"bytes,1,rep,name=txs,proto3" json:"txs,omitempty"`
	ProposedLastCommit v1.CommitInfo    `protobuf:"bytes,2,opt,name=proposed_last_commit,json=proposedLastCommit,proto3" json:"proposed_last_commit"`
	Misbehavior        []v1.Misbehavior `protobuf:"bytes,3,rep,name=misbehavior,proto3" json:"misbehavior"`
	Hash               []byte           `protobuf:"bytes,4,opt,name=hash,proto3" json:"hash,omitempty"`
	Height             int64            `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
	Time               time.Time        `protobuf:"bytes,6,opt,name=time,proto3,stdtime" json:"time"`
	NextValidatorsHash []byte           `protobuf:"bytes,7,opt,name=next_validators_hash,json=nextValidatorsHash,proto3" json:"next_validators_hash,omitempty"`
	ProposerAddress    []byte           `protobuf:"bytes,8,opt,name=proposer_address,json=proposerAddress,proto3" json:"proposer_address,omitempty"`
}) (*struct {
	Status v1.ProcessProposalStatus `protobuf:"varint,1,opt,name=status,proto3,enum=cometbft.abci.v1.ProcessProposalStatus" json:"status,omitempty"`
}, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for ProcessProposal")
	}

	var r0 *struct {
		Status v1.ProcessProposalStatus `protobuf:"varint,1,opt,name=status,proto3,enum=cometbft.abci.v1.ProcessProposalStatus" json:"status,omitempty"`
	}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *struct {
		Txs                [][]byte         `protobuf:"bytes,1,rep,name=txs,proto3" json:"txs,omitempty"`
		ProposedLastCommit v1.CommitInfo    `protobuf:"bytes,2,opt,name=proposed_last_commit,json=proposedLastCommit,proto3" json:"proposed_last_commit"`
		Misbehavior        []v1.Misbehavior `protobuf:"bytes,3,rep,name=misbehavior,proto3" json:"misbehavior"`
		Hash               []byte           `protobuf:"bytes,4,opt,name=hash,proto3" json:"hash,omitempty"`
		Height             int64            `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
		Time               time.Time        `protobuf:"bytes,6,opt,name=time,proto3,stdtime" json:"time"`
		NextValidatorsHash []byte           `protobuf:"bytes,7,opt,name=next_validators_hash,json=nextValidatorsHash,proto3" json:"next_validators_hash,omitempty"`
		ProposerAddress    []byte           `protobuf:"bytes,8,opt,name=proposer_address,json=proposerAddress,proto3" json:"proposer_address,omitempty"`
	}) (*struct {
		Status v1.ProcessProposalStatus `protobuf:"varint,1,opt,name=status,proto3,enum=cometbft.abci.v1.ProcessProposalStatus" json:"status,omitempty"`
	}, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *struct {
		Txs                [][]byte         `protobuf:"bytes,1,rep,name=txs,proto3" json:"txs,omitempty"`
		ProposedLastCommit v1.CommitInfo    `protobuf:"bytes,2,opt,name=proposed_last_commit,json=proposedLastCommit,proto3" json:"proposed_last_commit"`
		Misbehavior        []v1.Misbehavior `protobuf:"bytes,3,rep,name=misbehavior,proto3" json:"misbehavior"`
		Hash               []byte           `protobuf:"bytes,4,opt,name=hash,proto3" json:"hash,omitempty"`
		Height             int64            `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
		Time               time.Time        `protobuf:"bytes,6,opt,name=time,proto3,stdtime" json:"time"`
		NextValidatorsHash []byte           `protobuf:"bytes,7,opt,name=next_validators_hash,json=nextValidatorsHash,proto3" json:"next_validators_hash,omitempty"`
		ProposerAddress    []byte           `protobuf:"bytes,8,opt,name=proposer_address,json=proposerAddress,proto3" json:"proposer_address,omitempty"`
	}) *struct {
		Status v1.ProcessProposalStatus `protobuf:"varint,1,opt,name=status,proto3,enum=cometbft.abci.v1.ProcessProposalStatus" json:"status,omitempty"`
	}); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*struct {
				Status v1.ProcessProposalStatus `protobuf:"varint,1,opt,name=status,proto3,enum=cometbft.abci.v1.ProcessProposalStatus" json:"status,omitempty"`
			})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *struct {
		Txs                [][]byte         `protobuf:"bytes,1,rep,name=txs,proto3" json:"txs,omitempty"`
		ProposedLastCommit v1.CommitInfo    `protobuf:"bytes,2,opt,name=proposed_last_commit,json=proposedLastCommit,proto3" json:"proposed_last_commit"`
		Misbehavior        []v1.Misbehavior `protobuf:"bytes,3,rep,name=misbehavior,proto3" json:"misbehavior"`
		Hash               []byte           `protobuf:"bytes,4,opt,name=hash,proto3" json:"hash,omitempty"`
		Height             int64            `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
		Time               time.Time        `protobuf:"bytes,6,opt,name=time,proto3,stdtime" json:"time"`
		NextValidatorsHash []byte           `protobuf:"bytes,7,opt,name=next_validators_hash,json=nextValidatorsHash,proto3" json:"next_validators_hash,omitempty"`
		ProposerAddress    []byte           `protobuf:"bytes,8,opt,name=proposer_address,json=proposerAddress,proto3" json:"proposer_address,omitempty"`
	}) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Query provides a mock function with given fields: ctx, req
func (_m *Application) Query(ctx context.Context, req *struct {
	Data   []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Path   string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	Height int64  `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
	Prove  bool   `protobuf:"varint,4,opt,name=prove,proto3" json:"prove,omitempty"`
}) (*struct {
	Code      uint32             `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Log       string             `protobuf:"bytes,3,opt,name=log,proto3" json:"log,omitempty"`
	Info      string             `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
	Index     int64              `protobuf:"varint,5,opt,name=index,proto3" json:"index,omitempty"`
	Key       []byte             `protobuf:"bytes,6,opt,name=key,proto3" json:"key,omitempty"`
	Value     []byte             `protobuf:"bytes,7,opt,name=value,proto3" json:"value,omitempty"`
	ProofOps  *cryptov1.ProofOps `protobuf:"bytes,8,opt,name=proof_ops,json=proofOps,proto3" json:"proof_ops,omitempty"`
	Height    int64              `protobuf:"varint,9,opt,name=height,proto3" json:"height,omitempty"`
	Codespace string             `protobuf:"bytes,10,opt,name=codespace,proto3" json:"codespace,omitempty"`
}, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Query")
	}

	var r0 *struct {
		Code      uint32             `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
		Log       string             `protobuf:"bytes,3,opt,name=log,proto3" json:"log,omitempty"`
		Info      string             `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
		Index     int64              `protobuf:"varint,5,opt,name=index,proto3" json:"index,omitempty"`
		Key       []byte             `protobuf:"bytes,6,opt,name=key,proto3" json:"key,omitempty"`
		Value     []byte             `protobuf:"bytes,7,opt,name=value,proto3" json:"value,omitempty"`
		ProofOps  *cryptov1.ProofOps `protobuf:"bytes,8,opt,name=proof_ops,json=proofOps,proto3" json:"proof_ops,omitempty"`
		Height    int64              `protobuf:"varint,9,opt,name=height,proto3" json:"height,omitempty"`
		Codespace string             `protobuf:"bytes,10,opt,name=codespace,proto3" json:"codespace,omitempty"`
	}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *struct {
		Data   []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
		Path   string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
		Height int64  `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
		Prove  bool   `protobuf:"varint,4,opt,name=prove,proto3" json:"prove,omitempty"`
	}) (*struct {
		Code      uint32             `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
		Log       string             `protobuf:"bytes,3,opt,name=log,proto3" json:"log,omitempty"`
		Info      string             `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
		Index     int64              `protobuf:"varint,5,opt,name=index,proto3" json:"index,omitempty"`
		Key       []byte             `protobuf:"bytes,6,opt,name=key,proto3" json:"key,omitempty"`
		Value     []byte             `protobuf:"bytes,7,opt,name=value,proto3" json:"value,omitempty"`
		ProofOps  *cryptov1.ProofOps `protobuf:"bytes,8,opt,name=proof_ops,json=proofOps,proto3" json:"proof_ops,omitempty"`
		Height    int64              `protobuf:"varint,9,opt,name=height,proto3" json:"height,omitempty"`
		Codespace string             `protobuf:"bytes,10,opt,name=codespace,proto3" json:"codespace,omitempty"`
	}, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *struct {
		Data   []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
		Path   string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
		Height int64  `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
		Prove  bool   `protobuf:"varint,4,opt,name=prove,proto3" json:"prove,omitempty"`
	}) *struct {
		Code      uint32             `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
		Log       string             `protobuf:"bytes,3,opt,name=log,proto3" json:"log,omitempty"`
		Info      string             `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
		Index     int64              `protobuf:"varint,5,opt,name=index,proto3" json:"index,omitempty"`
		Key       []byte             `protobuf:"bytes,6,opt,name=key,proto3" json:"key,omitempty"`
		Value     []byte             `protobuf:"bytes,7,opt,name=value,proto3" json:"value,omitempty"`
		ProofOps  *cryptov1.ProofOps `protobuf:"bytes,8,opt,name=proof_ops,json=proofOps,proto3" json:"proof_ops,omitempty"`
		Height    int64              `protobuf:"varint,9,opt,name=height,proto3" json:"height,omitempty"`
		Codespace string             `protobuf:"bytes,10,opt,name=codespace,proto3" json:"codespace,omitempty"`
	}); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*struct {
				Code      uint32             `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
				Log       string             `protobuf:"bytes,3,opt,name=log,proto3" json:"log,omitempty"`
				Info      string             `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
				Index     int64              `protobuf:"varint,5,opt,name=index,proto3" json:"index,omitempty"`
				Key       []byte             `protobuf:"bytes,6,opt,name=key,proto3" json:"key,omitempty"`
				Value     []byte             `protobuf:"bytes,7,opt,name=value,proto3" json:"value,omitempty"`
				ProofOps  *cryptov1.ProofOps `protobuf:"bytes,8,opt,name=proof_ops,json=proofOps,proto3" json:"proof_ops,omitempty"`
				Height    int64              `protobuf:"varint,9,opt,name=height,proto3" json:"height,omitempty"`
				Codespace string             `protobuf:"bytes,10,opt,name=codespace,proto3" json:"codespace,omitempty"`
			})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *struct {
		Data   []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
		Path   string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
		Height int64  `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
		Prove  bool   `protobuf:"varint,4,opt,name=prove,proto3" json:"prove,omitempty"`
	}) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyVoteExtension provides a mock function with given fields: ctx, req
func (_m *Application) VerifyVoteExtension(ctx context.Context, req *struct {
	Hash             []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	ValidatorAddress []byte `protobuf:"bytes,2,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
	Height           int64  `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
	VoteExtension    []byte `protobuf:"bytes,4,opt,name=vote_extension,json=voteExtension,proto3" json:"vote_extension,omitempty"`
}) (*struct {
	Status v1.VerifyVoteExtensionStatus `protobuf:"varint,1,opt,name=status,proto3,enum=cometbft.abci.v1.VerifyVoteExtensionStatus" json:"status,omitempty"`
}, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for VerifyVoteExtension")
	}

	var r0 *struct {
		Status v1.VerifyVoteExtensionStatus `protobuf:"varint,1,opt,name=status,proto3,enum=cometbft.abci.v1.VerifyVoteExtensionStatus" json:"status,omitempty"`
	}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *struct {
		Hash             []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
		ValidatorAddress []byte `protobuf:"bytes,2,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
		Height           int64  `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
		VoteExtension    []byte `protobuf:"bytes,4,opt,name=vote_extension,json=voteExtension,proto3" json:"vote_extension,omitempty"`
	}) (*struct {
		Status v1.VerifyVoteExtensionStatus `protobuf:"varint,1,opt,name=status,proto3,enum=cometbft.abci.v1.VerifyVoteExtensionStatus" json:"status,omitempty"`
	}, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *struct {
		Hash             []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
		ValidatorAddress []byte `protobuf:"bytes,2,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
		Height           int64  `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
		VoteExtension    []byte `protobuf:"bytes,4,opt,name=vote_extension,json=voteExtension,proto3" json:"vote_extension,omitempty"`
	}) *struct {
		Status v1.VerifyVoteExtensionStatus `protobuf:"varint,1,opt,name=status,proto3,enum=cometbft.abci.v1.VerifyVoteExtensionStatus" json:"status,omitempty"`
	}); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*struct {
				Status v1.VerifyVoteExtensionStatus `protobuf:"varint,1,opt,name=status,proto3,enum=cometbft.abci.v1.VerifyVoteExtensionStatus" json:"status,omitempty"`
			})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *struct {
		Hash             []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
		ValidatorAddress []byte `protobuf:"bytes,2,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
		Height           int64  `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
		VoteExtension    []byte `protobuf:"bytes,4,opt,name=vote_extension,json=voteExtension,proto3" json:"vote_extension,omitempty"`
	}) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewApplication creates a new instance of Application. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewApplication(t interface {
	mock.TestingT
	Cleanup(func())
}) *Application {
	mock := &Application{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
